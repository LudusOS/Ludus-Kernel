name: Watch Linux Stable & Dispatch builds

on:
  schedule:
    - cron: "0 */3 * * *"   # cada 1h
  workflow_dispatch: {}

permissions:
  actions: write
  contents: write

jobs:
  watch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (guardar estado)
        uses: actions/checkout@v4

      - name: Herramientas
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Detectar última estable (no-EOL) de kernel.org y prefijar "v"
        id: kver
        shell: bash
        run: |
          set -euo pipefail
          JSON="$(curl -fsSL https://www.kernel.org/releases.json)"
          VER="$(printf '%s' "$JSON" \
            | jq -r '[.releases[]
                      | select(.moniker=="stable" and (.iseol|not))
                      ] | max_by(.released.timestamp) | .version')"
          if [ -z "${VER:-}" ] || [ "$VER" = "null" ]; then
            echo "::error::No se pudo obtener versión estable no-EOL"; exit 1
          fi
          if [[ "$VER" =~ ^v ]]; then
            VVER="$VER"
          else
            VVER="v$VER"
          fi
          echo "latest=$VVER" >> "$GITHUB_OUTPUT"
          echo "Último estable (con v): $VVER"

      - name: Comparar con estado previo
        id: state
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .state
          PREV="$(cat .state/latest_kernel.txt 2>/dev/null || true)"
          PREV="$(printf '%s' "$PREV" | tr -d '\r\n')"
          CUR="${{ steps.kver.outputs.latest }}"
          echo "prev=$PREV" >> "$GITHUB_OUTPUT"

          if [ "$PREV" = "$CUR" ]; then
            echo "dispatch=false" >> "$GITHUB_OUTPUT"
            echo "Sin cambios. Nada que disparar."
          else
            echo "$CUR" > .state/latest_kernel.txt
            echo "dispatch=true" >> "$GITHUB_OUTPUT"
            echo "Nueva versión detectada: $CUR"
          fi

      - name: Guardar estado (commit)
        if: steps.state.outputs.dispatch == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .state/latest_kernel.txt
          git commit -m "state: ${{ steps.kver.outputs.latest }}" || true
          git push

      # ===== Despacho único al workflow genérico, variando cpu_opt y cmdline =====
      - name: Dispatch variantes
        if: steps.state.outputs.dispatch == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          KVER: ${{ steps.kver.outputs.latest }}
        shell: bash
        run: |
          set -euo pipefail

          # Plataformas soportadas (sin 'native')
          CPU_OPTS=(
            "x86-64" "x86-64-v2" "x86-64-v3" "x86-64-v4"
            "znver1" "znver2" "znver3" "znver4" "znver5"
            "skylake" "tigerlake" "icelake-client"
            "rocketlake" "alderlake" "raptorlake"
            "meteorlake" "arrowlake" "arrowlake-s" "lunarlake"
          )

          # Cmdline por CPU
          cmdline_por_cpu() {
            case "$1" in
              # AMD Zen (znver2+)
              znver2|znver3|znver4|znver5)
                echo "quiet loglevel=3 systemd.show_status=auto udev.log_priority=3 amd_pstate=active nowatchdog nmi_watchdog=0 kernel.split_lock_mitigate=0 mitigations=off"
                ;;
              # Intel (familias específicas)
              skylake|tigerlake|icelake-client|rocketlake|alderlake|raptorlake|meteorlake|arrowlake|arrowlake-s|lunarlake)
                echo "quiet loglevel=3 systemd.show_status=auto udev.log_priority=3 intel_pstate=active nowatchdog nmi_watchdog=0 kernel.split_lock_mitigate=0 mitigations=off"
                ;;
              # x86-64, x86-64-v2, x86-64-v3, x86-64-v4, znver1, etc.
              *)
                echo "quiet loglevel=3 systemd.show_status=auto udev.log_priority=3 nowatchdog nmi_watchdog=0 kernel.split_lock_mitigate=0 mitigations=off"
                ;;
            esac
          }

          for CPU in "${CPU_OPTS[@]}"; do
            CMDLINE="$(cmdline_por_cpu "$CPU")"

            # Construimos payload con jq (evita problemas de comillas)
            PAYLOAD="$(jq -n \
              --arg ref "main" \
              --arg kver "$KVER" \
              --arg cpu  "$CPU" \
              --arg cmd  "$CMDLINE" \
              '{
                ref: $ref,
                inputs: {
                  kernel_version: $kver,
                  cpu_opt: $cpu,
                  custom_cmdline: $cmd
                }
              }'
            )"

            echo "Despachando build para cpu_opt=$CPU (kernel=$KVER)"
            CODE="$(curl -sS -o /dev/null -w '%{http_code}' -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $GH_TOKEN" \
              "https://api.github.com/repos/${REPO}/actions/workflows/Linux-Ludus-Bore-LLVM-BBR.yml/dispatches" \
              --data "$PAYLOAD")"

            if [ "$CODE" != "204" ]; then
              echo "::error::Dispatch falló para ${CPU} (HTTP $CODE)"
              exit 1
            fi
          done
